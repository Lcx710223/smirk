### LCX260108 SMIRK PYTORCH3D RENDERER RASTERIZE 中文注释：
def rasterize(self, vertices, faces, attributes=None, h=None, w=None):
    """
    使用 PyTorch3D 对网格进行光栅化，并根据重心坐标对每个像素插值顶点属性。

    参数:
        vertices:   (N, V, 3) 顶点坐标（NDC 空间）
        faces:      (N, F, 3) 三角面索引
        attributes: (N, V, D) 每个顶点的属性（如 RGB、法线等）
        h, w:       输出图像的高度和宽度（可选）

    返回:
        pixel_vals: (N, D+1, H, W)
            - 前 D 个通道：插值后的像素属性
            - 最后 1 个通道：可见性 mask（1=可见，0=背景）
    """

    # ----------------------------------------------------------------------
    # 1. 克隆顶点，并翻转 x,y 坐标
    #    PyTorch3D 的屏幕坐标系方向与 SMIRK/FLAME 不一致，因此需要取反。
    # ----------------------------------------------------------------------
    fixed_vertices = vertices.clone()
    fixed_vertices[..., :2] = -fixed_vertices[..., :2]

    # ----------------------------------------------------------------------
    # 2. 处理输出图像尺寸，并保持长宽比不变
    # ----------------------------------------------------------------------
    if h is None and w is None:
        image_size = self.image_size
    else:
        image_size = [h, w]

        # 根据长宽比缩放 x 或 y，避免渲染变形
        if h > w:
            fixed_vertices[..., 1] = fixed_vertices[..., 1] * h / w
        else:
            fixed_vertices[..., 0] = fixed_vertices[..., 0] * w / h

    # ----------------------------------------------------------------------
    # 3. 构建 PyTorch3D 的 Meshes 对象
    # ----------------------------------------------------------------------
    meshes_screen = Meshes(
        verts=fixed_vertices.float(),
        faces=faces.long()
    )

    # ----------------------------------------------------------------------
    # 4. 调用 PyTorch3D 的光栅化器
    #    返回:
    #       pix_to_face: 每个像素命中的三角面索引（-1 表示背景）
    #       zbuf:        深度值
    #       bary_coords: 重心坐标（用于插值）
    #       dists:       像素到三角面的距离
    # ----------------------------------------------------------------------
    pix_to_face, zbuf, bary_coords, dists = rasterize_meshes(
        meshes_screen,
        image_size=image_size,
        blur_radius=0.0,
        faces_per_pixel=1,       # 每个像素只保留最近的一个三角面
        bin_size=None,
        max_faces_per_bin=None,
        perspective_correct=False,
    )

    # ----------------------------------------------------------------------
    # 5. 可见性 mask：命中三角面为 1，背景为 0
    # ----------------------------------------------------------------------
    vismask = (pix_to_face > -1).float()

    # ----------------------------------------------------------------------
    # 6. 准备顶点属性，用于重心插值
    #    attributes: (N, V, D) → reshape 为 (N*F, 3, D)
    # ----------------------------------------------------------------------
    D = attributes.shape[-1]
    attributes = attributes.clone()
    attributes = attributes.view(
        attributes.shape[0] * attributes.shape[1], 3, D
    )

    # ----------------------------------------------------------------------
    # 7. 获取光栅化输出的维度
    # ----------------------------------------------------------------------
    N, H, W, K, _ = bary_coords.shape

    # ----------------------------------------------------------------------
    # 8. 处理背景像素（pix_to_face = -1）
    #    为避免 gather() 报错，将 -1 临时替换为 0
    # ----------------------------------------------------------------------
    mask = pix_to_face == -1
    pix_to_face = pix_to_face.clone()
    pix_to_face[mask] = 0

    # ----------------------------------------------------------------------
    # 9. 根据 pix_to_face 取出每个像素对应三角面的 3 个顶点属性
    # ----------------------------------------------------------------------
    idx = pix_to_face.view(N * H * W * K, 1, 1).expand(
        N * H * W * K, 3, D
    )
    pixel_face_vals = attributes.gather(0, idx)
    pixel_face_vals = pixel_face_vals.view(N, H, W, K, 3, D)

    # ----------------------------------------------------------------------
    # 10. 使用重心坐标对属性进行插值
    #     pixel_val = b1*A + b2*B + b3*C
    # ----------------------------------------------------------------------
    pixel_vals = (bary_coords[..., None] * pixel_face_vals).sum(dim=-2)

    # ----------------------------------------------------------------------
    # 11. 背景像素设为 0
    # ----------------------------------------------------------------------
    pixel_vals[mask] = 0

    # ----------------------------------------------------------------------
    # 12. 去掉 faces_per_pixel 维度，并调整为 (N, D, H, W)
    # ----------------------------------------------------------------------
    pixel_vals = pixel_vals[:, :, :, 0].permute(0, 3, 1, 2)

    # ----------------------------------------------------------------------
    # 13. 将可见性 mask 作为最后一个通道拼接
    # ----------------------------------------------------------------------
    pixel_vals = torch.cat(
        [pixel_vals, vismask[:, :, :, 0][:, None, :, :]],
        dim=1
    )

    return pixel_vals
